/*
 * FILENAME: prog1.c
 *
 * Copyright Empower Technologies Incorporated 2005.
 * All Rights Reserved.
 * #405 - 5600 Parkwood Way,
 * Crestwood Commerce Centre,
 * Richmond, B.C., Canada V6V 2M2
 *
 * The copyright to this source code and application(s) herein is the
 * property of Empower Technologies Inc, Canada. This source code and
 * or the applications may be used modified or copied only with written
 * permission of Empower Technologies or in accordance with the terms
 * and conditions stipulated in the agreement or contract under which
 * this source and or application have been supplied. This copyright
 * notice must not be removed.
 *
 * Author(s): Empower Technologies Incorporated
 *
 * Initially Released: April 15, 2005    Build/Version: 1.0
 * Initial release target: EPT_LDK_5912
 *
 * Description:
 * Program 1 is a very simple introduction to forms and GUI messages.
 * It demonstrates the use of the form components caption, label and button,
 * and the GUI messages generated by a button click.
 *
 */
// for testing svn user name

#include <unistd.h>
#include "linux/gui.h"
#include <pthread.h>
#include "daqGUI.rsrc"
#include <stdio.h>

//#include "wave_recorder.h"


#define MENU_FILE 				10
#define MENUITEM_EXIT			12
#define IDD_TEST				30
#define IDD_TEST1				40
#define START                   50
#define PLOT                    60
#define STOP                    70
#define DRAW_ONE_GRAPH          80

static FORMCAPTION frm_caption = { "Sample", NULL };

static FORM frmSample[] = { { FORM_CAPTION, 0, 0, 0, SCREEN_WIDTH, SCREEN_HEIGHT - TASKBAR_HEIGHT, &frm_caption,
		FORM_FRAME_CAPTION, 0, 0 }, { FORM_MENU, MENU_FILE, 5, 20, 0, 0, "File", 0, COMPONENT_VISIBLE }, {
		FORM_MENUITEM, MENUITEM_EXIT, 5, 20, 0, 0, "Exit", 0 }, { FORM_BUTTON, START, 4, 270, 37, 22, "INIT", 0,
		COMPONENT_VISIBLE, FONT_SMALL },
		{ FORM_BUTTON, PLOT, 43, 270, 37, 22, "PLOT", 0, COMPONENT_VISIBLE, FONT_SMALL }, { FORM_BUTTON, STOP, 82, 270,
				37, 22, "STOP", 0, COMPONENT_VISIBLE, FONT_SMALL }, { FORM_BUTTON, DRAW_ONE_GRAPH, 199, 270, 37, 22,
				"DRAW", 0, COMPONENT_VISIBLE, FONT_SMALL }, { FORM_END }, };

int dumb = 1;
pthread_t pid;

void ShowSample(void);
void wait_loop(void);
// plot function draws a graph of 200x200 resolution
void plot_200x200(int num);
void drawAxis();
void plotAudioData();
//void drawEcgGraph(struct Graph G1, GraphicsContext gc,double *data_1,double *data_2);

int main(int argc, char *argv[])
{
	short launch_cmd;

	launch_cmd = GetLaunchCommand(argc, argv);
	init_screen(launch_cmd);

	switch (launch_cmd)
	{
		case CMD_RUN_NORMAL:
			ShowSample();
			break;
		case CMD_RUN_GET_INFO:
			PutAppInfo(&app_info);
			break;
		case CMD_RUN_GET_VERSION:
			PutVersionInfo(&app_info);
			break;
	}
	close_screen();
	return 0;
}

void ShowSample(void)
{
	ClearMessageQueue();
	CreateForm(frmSample);
	wait_loop();
}

void wait_loop(void)
{
	GUI_MSG msg;
	U8 Flag = 1;
	//int argc;
	//char *argv[4];
	int *gOneData;
	int gOneDataSize;
	int sampleFreq = 44100;

	while (Flag)
	{
		GetMessage(frmSample, &msg);
		switch (msg.event)
		{
			case EVENT_KEYUP:
				switch (msg.keycode)
				{
					case KEY_RETURN:
						Flag = 0;
						break;

					default:
						DefaultMessageRoutine(frmSample, &msg);
				}
				break;

			case EVENT_CLICK:
				switch (msg.id)
				{
					case MENUITEM_EXIT: //Close dialog and go out
						Flag = 0;
						CloseForm(frmSample);
						break;

					case START:
						printf("\nINIT button Pressed\n");

						// set up the DSP side.
						setupDSP(sampleFreq, "/xbin/wav_rec_rf6_dsp.out", "isip-e.wav");
						printf("\n startDSP(..) function has been completed. \n");

						// start the thread that writes the dsp data to a wav file.
						startStreamThread(sampleFreq);
						printf("\n startStreamThread(..) function has been completed. \n");

						break;

					case PLOT:
						printf("\nPLOT button Pressed\n");
						//printf("The 1st buffer entry is %d and the data size is %d \n", gOneData[0], gOneDataSize);

						drawAxis();
						plotAudioData();

						break;

					case DRAW_ONE_GRAPH:
						printf("DRAW EEG button Pressed\n");
						//Draw_Graph();
						plot_200x200(1);
						printf("DRAW DONE! \n");
						break;

					case STOP:
						printf("\nSTOP button Pressed\n");
						printf("\n Leaving Reference Framework 6 audio application\n\n");

						stopDSP();
						stopStreamThread();

						//CallApp("/sound/stop.sh");
						//printf("RECORDING STOPPED!\n");
						break;

						/*  case PLAY:
						 printf("PLAY button Pressed\n");
						 // copy the background of the screen
						 //CopyScreen(background,0,0,SCREEN_WIDTH,SCREEN_HEIGHT);
						 //call save data bash file
						 CallApp("/sound/play.sh");
						 printf("PLAYING.. \n");
						 // paste the background screen
						 //PasteScreen(background,0,0,SCREEN_WIDTH,SCREEN_HEIGHT);
						 break; */

					default:
						DefaultMessageRoutine(frmSample, &msg);

				} // end of EVENT_CLICK
				break;

			default:
				DefaultMessageRoutine(frmSample, &msg);
		}
	} /**** end of message loop *****/
}

// graph attributes for plot function
struct Graph
{
	// y-axis attributes
	int max_y;
	int min_y;
	char label_y[20];
	//strcpy(label_y,"micro-volt");
	// x-axis attributes
	int max_x;
	int min_x;
	char label_x[20];
	// char *ptr;
	//ptr = strcpy(label_x,"seconds");
	// eeg is stored here
	double data[1024*7];
	// size of data
	int data_size;
};

/**
 * This function draws the Plot axis for the graph.
 */
void drawAxis()
{
	GraphicsContext gc;
	RECT r;

	// draw a white rectangle to delete what was previously on the screen.

	gc.mode = Mode_SRC;
	gc.fill_index = WhitePattern;
	gc.color = GUI_YELLOW;
	r.left=10;
	r.right = 200;
	r.top = 50;
	r.bottom = 260;
	FillRect(r,&gc);


	// draw the y-axis. The numbers represents pixels
	// 20 = left margin. 20 = total top margin. 260 = 240 + 20 total margin
	draw_line(20, 20, 20, 260, GUI_BLACK);
	// draw the x-axis. The numbers represents pixels
	// 20 = left margin. 140 = 40 total top margin + 100 positive y portion.
	// 220 = 20 leftmargin + 200 length of x-axis
	draw_line(20, 80, 220, 80, GUI_BLACK);
	draw_line(20, 200, 220, 200, GUI_BLACK);

	//draw y-axis' notches
	draw_line(17, 140, 20, 140, GUI_BLACK); // 0 notch could be built within x-axis
	draw_line(17, 20, 20, 20, GUI_BLACK); // max notch
	draw_line(17, 260, 20, 260, GUI_BLACK); // min notch

	//draw x-axis' notches
	//draw_line(20, 138, 20, 142, GUI_BLACK); // 0 notch could be built within x-axis
	draw_line(220, 78, 220, 82, GUI_BLACK); // max notch for first axis
	draw_line(120, 78, 120, 82, GUI_BLACK); //mid notch for first axis
	draw_line(220, 198, 220, 202, GUI_BLACK); // max notch for second axis
	draw_line(120, 198, 120, 202, GUI_BLACK); // mid notch

}

/**
 * Takes the data given in "buffer" and plots it on the screen.
 */
void drawGraph(struct Graph G1, GraphicsContext gc, short *aud_data1,short *aud_data2)
{
	int i, j;

	int x_range; // range of the x-axis
	int y_range; // range of the y-axis
	int x_factor; // scale factor of pixels to time(=size) of data
	int y_factor; // scale factor of pixels to amplitude(=value) of data

	// range and factor calculations
	x_range =250; // G1.max_x - G1.min_x;
	y_range = G1.max_y - G1.min_y;;
	x_factor = x_range / 200.0; // 200 = number of pixels in x direction = towards left/right of screen
	y_factor = y_range / 200.0; // 200 = number of pixels in y direction = towards up/down of screen

	printf("x_range=%d \t", x_range);
	printf("y_range=%d \t", y_range);
	printf("x_factor=%d \t", x_factor);
	printf("y_factor=%d \n", y_factor);

	//set graphic content parameters, i.e. color, mode...
	//gc.color = GUI_BLACK;
	gc.mode = Mode_SRC;
	gc.fill_index = BlackPattern;

	// draw the data. The numbers represents pixels
	// start from time =100
	for (i = 0, j = 0; i < 250 && j < 200 - 1; i += x_factor, j++)
		// 20 = left margin.
		// 140 position of x axis on screen = 100 + 20 (top margin) + 20 (file menu area).
		//draw_line(j + 20, 80 - ((short) G1.data[i] / y_factor), j + 1 + 20, 80 - ((short) G1.data[i + 1] / y_factor),	gc.color);
	{
		draw_line(j + 20, 80 - ((short) aud_data1[i] / y_factor), j + 1 + 20, 80 - ((short) aud_data1[i + 1] / y_factor),gc.color);
		draw_line(j + 20, 200 - ((short) aud_data2[i] / y_factor), j + 1 + 20, 200 - ((short) aud_data2[i + 1] / y_factor),gc.color);
    }
}

//void drawEcgGraph(struct Graph G1, GraphicsContext gc,short *data_1,short *data_2)
//{
//	int i, j, p;
//	//double data_1[300];
//	//double data_2[300];
//
//	int x_range; // range of the x-axis
//	int y_range; // range of the y-axis
//	int x_factor; // scale factor of pixels to time(=size) of data
//	int y_factor; // scale factor of pixels to amplitude(=value) of data
//
//	// range and factor calculations
//	x_range = G1.max_x - G1.min_x;
//	y_range = G1.max_y - G1.min_y;;
//	x_factor = x_range / 200.0; // 200 = number of pixels in x direction = towards left/right of screen
//	y_factor = y_range / 200.0; // 200 = number of pixels in y direction = towards up/down of screen
//
//	printf("x_range=%d \t", x_range);
//	printf("y_range=%d \t", y_range);
//	printf("x_factor=%d \t", x_factor);
//	printf("y_factor=%d \n", y_factor);
//
//	//set graphic content parameters, i.e. color, mode...
//	//gc.color = GUI_BLACK;
//	gc.mode = Mode_SRC;
//	gc.fill_index = BlackPattern;
//
//	// draw the data. The numbers represents pixels
//	// start from time =100
//	for (i = 100, j = 0; i < G1.data_size && j < 200 - 1; i += x_factor, j++)
//		// 20 = left margin.
//		// 140 position of x axis on screen = 100 + 20 (top margin) + 20 (file menu area).
//		draw_line(j + 20, 80 - ((short) data_1[p] / y_factor), j + 1 + 20, 80 - ((short) data_1[p+1] / y_factor),	gc.color);
//	    draw_line(j + 20, 200 - ((short) data_2[p] / y_factor), j + 1 + 20, 200 - ((short) data_2[p+1] / y_factor),	gc.color);
//
//
//}

void drawEcgGraph(struct Graph G1, GraphicsContext gc,short *data_1,short *data_2)
{
	int i, j;

	int x_range; // range of the x-axis
	int y_range; // range of the y-axis
	int x_factor; // scale factor of pixels to time(=size) of data
	int y_factor; // scale factor of pixels to amplitude(=value) of data

	// range and factor calculations
	x_range = 250;//G1.max_x - G1.min_x;
	y_range = G1.max_y - G1.min_y;;
	x_factor = x_range / 200.0; // 200 = number of pixels in x direction = towards left/right of screen
	y_factor = y_range / 200.0; // 200 = number of pixels in y direction = towards up/down of screen

	printf("x_range=%d \t", x_range);
	printf("y_range=%d \t", y_range);
	printf("x_factor=%d \t", x_factor);
	printf("y_factor=%d \n", y_factor);

	//set graphic content parameters, i.e. color, mode...
	//gc.color = GUI_BLACK;
	gc.mode = Mode_SRC;
	gc.fill_index = BlackPattern;

	// draw the data. The numbers represents pixels
	// start from time =100
	for (i = 0, j = 0; i < 250 && j < 200 - 1; i += x_factor, j++)
		// 20 = left margin.
		// 140 position of x axis on screen = 100 + 20 (top margin) + 20 (file menu area).
	{
		draw_line(j + 20, 80 - ((short) data_1[i] / y_factor), j + 1 + 20, 80 - ((short) data_1[i + 1] / y_factor),	gc.color);
	    draw_line(j + 20, 200 - ((short) data_2[i] / y_factor), j + 1 + 20, 200 - ((short) data_2[i + 1] / y_factor),	gc.color);
		//draw_line(j + 20, 200 - ((short) G1.data[i] / y_factor), j + 1 + 20, 200 - ((short) G1.data[i + 1] / y_factor),	gc.color);
    }
}// end of for loop
void plotAudioData()
{
	//double audiodata[1024*7];
	struct Graph G1;
	GraphicsContext gc;
	int i,q;
	short aud_data1[300];
	short aud_data2[300];

	// construct the Graph structure from the data:
	G1.max_y = 2500;
	G1.min_y = -2500;
	G1.max_x = 500;
	G1.min_x = 0;
	G1.data_size = 500; // = G1.max_x - G1.min_x = x_range

	// fills the audiodata buffer with content:
	getDataSnapshot(&G1.data);

	  for(i=0,q=0;i<250;i+=2,q++)
	  {
		  aud_data1[q] = G1.data[i];
		  aud_data2[q] = G1.data[i+1];
	  }

	  printf("\n Audiodata Demultiplexed\n");

	// construct the GraphicsContext structure from the data:
	gc.color = GUI_BLUE;


	// draw the graph on the screen:
	drawGraph(G1, gc,aud_data1,aud_data2);

}

void plot_200x200(int num)
{
	int i,p;
	struct Graph G1;
	GraphicsContext gc;
	FILE * data_file;
	short data_1[300];
	short data_2[300];


	printf("start plot_200x200\n");
	// open data file... If not successful print error

	switch (num)
	{
		case 1: // draw data in ISIP file
			if ((data_file = fopen("/root/ISIP.txt", "r")) == NULL)
				printf("Cannot open %s\n", data_file);
			gc.color = GUI_RED;
			// initialize graph varriables
			G1.max_y = 300; // before it was 2500
			G1.min_y = -300; // before it was -2500
			break;
		case 2: // draw A-trous in ISIP file
			if ((data_file = fopen("/root/d1.csv", "r")) == NULL)
				printf("Cannot open %s\n", data_file);
			gc.color = GUI_BLUE;
			// initialize graph varriables
			G1.max_y = 700;
			G1.min_y = -700;
			break;
		case 3: // draw A-trous in ISIP file
			if ((data_file = fopen("/root/d2.csv", "r")) == NULL)
				printf("Cannot open %s\n", data_file);
			gc.color = GUI_GREEN;
			// initialize graph varriables
			G1.max_y = 700;
			G1.min_y = -700;
			break;
		default:
			printf("\nNo draw command given!\n");
	}

	// initialize graph varriables
	//G1.max_y=2500;
	//G1.min_y=-2500;
	strcpy(G1.label_y, "micro-volt");
	G1.max_x = 500;
	G1.min_x = 0;
	strcpy(G1.label_x, "micro-volt");
	G1.data_size = 500; // = G1.max_x - G1.min_x = x_range

	// read from the data file and store into array.
	for (i = 0; i < G1.data_size; i++)
		fscanf(data_file, "%lf", &G1.data[i]);
//	for(i=0,p=0; i< 500; i+=2,p++)
//		This loop is when plotting a single channel graph for 500 elements
		for(i=0,p=0; i< 250; i+=2,p++)
	{
		data_1[p] = G1.data[i];
		data_2[p] = G1.data[i+1];
	}

	//printf("First element in the file is %d\n", G1.data[0]);
	//printf("Last element in the file is %d\n", G1.data[G1.data_size - 1]);

	printf("Data is being Demultiplexed\n");

	//      while(!feof(data_file)) {
	//      // read as long as there is data
	//      fscanf(data_file, "%d", &numbers[i]);
	//      i++;
	//    }

	// close the data file
	fclose(data_file);

	// draw the Plot axis for the graph.
	drawAxis();

	// draw the Graph.
	drawEcgGraph(G1,gc,data_1,data_2);
	//drawEcgGraph(G1,gc);

	printf("END plot_200x200 \n");
}
